import { PnpmError } from '@pnpm/error';
import { type FetchFromRegistry, type GetAuthHeader, type RetryTimeoutOptions } from '@pnpm/fetching-types';
import { type PreferredVersions, type ResolveResult, type WantedDependency, type WorkspacePackages } from '@pnpm/resolver-base';
import { type PackageMeta, type PackageMetaCache } from './pickPackage';
import { parsePref, type RegistryPackageSpec } from './parsePref';
import { RegistryResponseError } from './fetch';
import { workspacePrefToNpm } from './workspacePrefToNpm';
export declare class NoMatchingVersionError extends PnpmError {
    readonly packageMeta: PackageMeta;
    constructor(opts: {
        wantedDependency: WantedDependency;
        packageMeta: PackageMeta;
    });
}
export { parsePref, workspacePrefToNpm, type PackageMeta, type PackageMetaCache, type RegistryPackageSpec, RegistryResponseError, };
export interface ResolverFactoryOptions {
    cacheDir: string;
    fullMetadata?: boolean;
    filterMetadata?: boolean;
    offline?: boolean;
    preferOffline?: boolean;
    retry?: RetryTimeoutOptions;
    timeout?: number;
}
export declare function createNpmResolver(fetchFromRegistry: FetchFromRegistry, getAuthHeader: GetAuthHeader, opts: ResolverFactoryOptions): (wantedDependency: WantedDependency, opts: ResolveFromNpmOptions) => Promise<ResolveResult | null>;
export type ResolveFromNpmOptions = {
    alwaysTryWorkspacePackages?: boolean;
    defaultTag?: string;
    publishedBy?: Date;
    pickLowestVersion?: boolean;
    dryRun?: boolean;
    lockfileDir?: string;
    registry: string;
    preferredVersions?: PreferredVersions;
    preferWorkspacePackages?: boolean;
    updateToLatest?: boolean;
} & ({
    projectDir?: string;
    workspacePackages?: undefined;
} | {
    projectDir: string;
    workspacePackages: WorkspacePackages;
});
