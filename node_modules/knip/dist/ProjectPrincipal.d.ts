import ts from 'typescript';
import { createCustomModuleResolver } from './typescript/resolveModuleNames.js';
import { SourceFileManager } from './typescript/SourceFileManager.js';
import type { SyncCompilers, AsyncCompilers } from './compilers/types.js';
import type { PrincipalOptions } from './PrincipalFactory.js';
import type { SerializableExportMember } from './types/exports.js';
import type { UnresolvedImport } from './types/imports.js';
import type { ProgramMaybe53 } from './typescript/SourceFile.js';
import type { ReferencedDependencies } from './WorkspaceWorker.js';
type AnalyzeSourceFileOptions = {
    skipTypeOnly: boolean;
    isFixExports: boolean;
    isFixTypes: boolean;
    ignoreExportsUsedInFile: boolean;
};
export declare class ProjectPrincipal {
    entryPaths: Set<string>;
    projectPaths: Set<string>;
    referencedDependencies: Set<[string, string, string]>;
    skipExportsAnalysis: Set<string>;
    isGitIgnored: (path: string) => boolean;
    cwd: string;
    compilerOptions: ts.CompilerOptions;
    extensions: Set<string>;
    syncCompilers: SyncCompilers;
    asyncCompilers: AsyncCompilers;
    backend: {
        fileManager: SourceFileManager;
        compilerHost: ts.CompilerHost;
        resolveModuleNames: ReturnType<typeof createCustomModuleResolver>;
        program?: ProgramMaybe53;
        typeChecker?: ts.TypeChecker;
        languageServiceHost: ts.LanguageServiceHost;
    };
    findReferences?: ts.LanguageService['findReferences'];
    constructor({ compilerOptions, cwd, compilers, isGitIgnored }: PrincipalOptions);
    init(): void;
    addPaths(paths: ts.CompilerOptions['paths']): void;
    addCompilers(compilers: [SyncCompilers, AsyncCompilers]): void;
    private createProgram;
    private hasAcceptedExtension;
    addEntryPath(filePath: string, options?: {
        skipExportsAnalysis: boolean;
    }): void;
    addEntryPaths(filePaths: Set<string> | string[], options?: {
        skipExportsAnalysis: boolean;
    }): void;
    addProjectPath(filePath: string): void;
    addReferencedDependencies(workspaceName: string, referencedDependencies: ReferencedDependencies): void;
    runAsyncCompilers(): Promise<void>;
    getUsedResolvedFiles(): string[];
    private getProgramSourceFiles;
    getUnreferencedFiles(): string[];
    analyzeSourceFile(filePath: string, options: AnalyzeSourceFileOptions): {
        imports: {
            internal: import("./types/imports.js").SerializableImportMap;
            unresolved: Set<UnresolvedImport>;
            external: Set<string>;
        };
        exports: {
            exported: import("./types/exports.js").SerializableExports;
            duplicate: import("./types/issues.js").IssueSymbol[][];
        };
        scripts: Set<string>;
    };
    resolveModule(specifier: string, filePath?: string): ts.ResolvedModuleFull | undefined;
    findUnusedMembers(filePath: string, members: SerializableExportMember[]): SerializableExportMember[];
}
export {};
